// Generated by CoffeeScript 1.10.0
(function() {
  var ActionTypes, ControlActions, chai, expect, sinon, sinonChai, spy;

  ControlActions = require('../../js/actions/ControlActions');

  ActionTypes = require('../../js/constants/ActionTypes');

  chai = require('chai');

  sinon = require('sinon');

  sinonChai = require('sinon-chai');

  chai.use(sinonChai);

  spy = sinon.spy;

  expect = chai.expect;

  describe('ControlActions', function() {
    beforeEach(function() {
      return this.dispatch = spy();
    });
    describe('changeNote', function() {
      describe('when the note is already the current note', function() {
        beforeEach(function() {
          var getState, thunk;
          thunk = ControlActions.changeNote(0);
          getState = function() {
            return {
              currentNote: 0
            };
          };
          return thunk(this.dispatch, getState);
        });
        return it('should not @dispatch any actions', function() {
          return expect(this.dispatch).to.not.have.been.called;
        });
      });
      describe('when the current note is empty', function() {
        describe('when the current note is the first note', function() {
          beforeEach(function() {
            var getState, thunk;
            thunk = ControlActions.changeNote(1);
            getState = function() {
              return {
                currentNote: 0,
                notes: [
                  {
                    text: '',
                    title: ''
                  }, {
                    text: 'text',
                    title: 'title'
                  }
                ]
              };
            };
            return thunk(this.dispatch, getState);
          });
          it('should delete the current note', function() {
            return expect(this.dispatch.args[0][0]).to.eql({
              type: ActionTypes.NOTE_DELETED,
              payload: {
                noteId: 0
              }
            });
          });
          return it('should change to the correct note', function() {
            return expect(this.dispatch.args[1][0]).to.eql({
              type: ActionTypes.NOTE_CHANGED,
              payload: {
                noteId: 0
              }
            });
          });
        });
        return describe('when the current note is NOT the first note', function() {
          beforeEach(function() {
            var getState, thunk;
            thunk = ControlActions.changeNote(0);
            getState = function() {
              return {
                currentNote: 1,
                notes: [
                  {
                    text: 'text',
                    title: 'title'
                  }, {
                    text: '',
                    title: ''
                  }
                ]
              };
            };
            return thunk(this.dispatch, getState);
          });
          it('should delete the current note', function() {
            return expect(this.dispatch.args[0][0]).to.eql({
              type: ActionTypes.NOTE_DELETED,
              payload: {
                noteId: 1
              }
            });
          });
          return it('should change to the correct note', function() {
            return expect(this.dispatch.args[1][0]).to.eql({
              type: ActionTypes.NOTE_CHANGED,
              payload: {
                noteId: 0
              }
            });
          });
        });
      });
      return describe('default', function() {
        beforeEach(function() {
          var getState, thunk;
          thunk = ControlActions.changeNote(1);
          getState = function() {
            return {
              currentNote: 0,
              notes: [
                {
                  text: 'text0',
                  title: 'title0'
                }, {
                  text: 'text',
                  title: 'title'
                }
              ]
            };
          };
          return thunk(this.dispatch, getState);
        });
        it('should change to the correct note', function() {
          return expect(this.dispatch.args[0][0]).to.eql({
            type: ActionTypes.NOTE_CHANGED,
            payload: {
              noteId: 1
            }
          });
        });
        return it('should not delete any notes', function() {
          return expect(this.dispatch.callCount).to.equal(1);
        });
      });
    });
    describe('createNote', function() {
      beforeEach(function() {
        var getState, thunk;
        thunk = ControlActions.createNote();
        getState = function() {
          return {
            currentNote: 0,
            notes: [
              {
                title: 'title',
                text: 'text'
              }, {
                title: 'title2',
                text: 'text2'
              }
            ]
          };
        };
        return thunk(this.dispatch, getState);
      });
      it('should create a note', function() {
        return expect(this.dispatch.firstCall).to.have.been.calledWith({
          type: ActionTypes.NOTE_CREATED
        });
      });
      return it('should change to the new note', function() {
        return expect(this.dispatch.secondCall).to.have.been.calledWith({
          type: ActionTypes.NOTE_CHANGED,
          payload: {
            noteId: 1
          }
        });
      });
    });
    describe('changeTitle', function() {
      beforeEach(function() {
        var getState, thunk;
        thunk = ControlActions.changeTitle('aNewTitle');
        getState = function() {
          return {
            currentNote: 0,
            notes: [
              {
                title: 'title',
                text: 'text'
              }
            ]
          };
        };
        return thunk(this.dispatch, getState);
      });
      return it('should change the current note\'s title', function() {
        return expect(this.dispatch).to.have.been.calledWith({
          type: ActionTypes.TITLE_CHANGED,
          payload: {
            title: 'aNewTitle',
            noteId: 0
          }
        });
      });
    });
    return describe('deleteNote', function() {
      describe('when deleting an empty note', function() {
        describe('when it isn\'t the last remaining note', function() {
          beforeEach(function() {
            var getState, thunk;
            this.confirmStub = sinon.stub(window, 'confirm', function() {
              return false;
            });
            thunk = ControlActions.deleteNote();
            getState = function() {
              return {
                currentNote: 0,
                notes: [
                  {
                    title: '',
                    text: ''
                  }, {
                    text: '',
                    title: ''
                  }
                ]
              };
            };
            return thunk(this.dispatch, getState);
          });
          it('should delete the note', function() {
            return expect(this.dispatch.firstCall).to.have.been.calledWith({
              type: ActionTypes.NOTE_DELETED,
              payload: {
                noteId: 0
              }
            });
          });
          it('should not prompt the user', function() {
            return expect(this.confirmStub).to.not.have.been.called;
          });
          it('should not create a new note', function() {
            return expect(this.dispatch.callCount).to.equal(1);
          });
          return afterEach(function() {
            return this.confirmStub.restore();
          });
        });
        return describe('when it is the last remaining note', function() {
          beforeEach(function() {
            var getState, thunk;
            this.confirmStub = sinon.stub(window, 'confirm', function() {
              return false;
            });
            thunk = ControlActions.deleteNote();
            getState = sinon.stub();
            getState.onFirstCall().returns({
              currentNote: 0,
              notes: [
                {
                  title: '',
                  text: ''
                }
              ]
            });
            getState.onSecondCall().returns({
              currentNote: 0,
              notes: []
            });
            getState.returns({
              currentNote: 0,
              notes: [
                {
                  title: '',
                  text: ''
                }
              ]
            });
            return thunk(this.dispatch, getState);
          });
          it('should delete the note', function() {
            return expect(this.dispatch.firstCall).to.have.been.calledWith({
              type: ActionTypes.NOTE_DELETED,
              payload: {
                noteId: 0
              }
            });
          });
          it('should not prompt the user', function() {
            return expect(this.confirmStub).to.not.have.been.called;
          });
          it('should create a new note', function() {
            return expect(this.dispatch.secondCall).to.have.been.calledWith({
              type: ActionTypes.NOTE_CREATED
            });
          });
          return afterEach(function() {
            return this.confirmStub.restore();
          });
        });
      });
      return describe('when deleting a note with content', function() {
        describe('when the user cancels the deletion', function() {
          beforeEach(function() {
            var getState;
            this.confirmStub = sinon.stub(window, 'confirm', function() {
              return false;
            });
            this.thunk = ControlActions.deleteNote();
            getState = function() {
              return {
                currentNote: 0,
                notes: [
                  {
                    title: 'title',
                    text: 'text'
                  }, {
                    title: 'title2',
                    text: 'text2'
                  }
                ]
              };
            };
            return this.thunk(this.dispatch, getState);
          });
          it('should prompt the user', function() {
            return expect(window.confirm).to.have.been.called;
          });
          it('should not dispatch anything', function() {
            return expect(this.dispatch).to.not.have.been.called;
          });
          return afterEach(function() {
            return this.confirmStub.restore();
          });
        });
        return describe('when the user accepts the deletion', function() {
          beforeEach(function() {
            var getState;
            this.confirmStub = sinon.stub(window, 'confirm', function() {
              return true;
            });
            this.thunk = ControlActions.deleteNote();
            getState = function() {
              return {
                currentNote: 0,
                notes: [
                  {
                    title: 'title',
                    text: 'text'
                  }, {
                    title: 'title2',
                    text: 'text2'
                  }
                ]
              };
            };
            return this.thunk(this.dispatch, getState);
          });
          it('should prompt the user', function() {
            return expect(window.confirm).to.have.been.called;
          });
          it('should dispatch things', function() {
            return expect(this.dispatch).to.have.been.called;
          });
          return afterEach(function() {
            return this.confirmStub.restore();
          });
        });
      });
    });
  });

}).call(this);
